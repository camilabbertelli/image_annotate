## @package camicasa
# package for all functions, methods and classes create by Camila Bertelli

import os
import io
import sys
import gui
import shutil
import splitfolders
from glob import glob
from PIL import Image
from gui import sg

## Class destinated to store information about an image in the classification context
class ClassifImage:
    globalIndex = 0

    ## The constructor
    # @param self The object pointer
    # @param path The complete image path
    # @param name The image the image will go by, containing the extension, i.e. image.jpg, 001.png
    def __init__(self, path : str, name: str) -> 'ClassifImage':
        self.index = ClassifImage.globalIndex
        ClassifImage.globalIndex += 1
        self.path = path
        self.name = name
        # list of Label
        self.labels = list()

## Returns list of strings to be presented in the labels listbox,
# considering number on the left
# @param vectorLabels vector of labels to add indexes on the left
def getLabelsNameList(vectorLabels : list) -> list:
    aux = list()
    for label in vectorLabels:
        index = labels.index(label)
        aux.append(str(index + 1) + ": " + label)
    return aux

## Loads image on image container(sg.Image) and updates related information 
# @param window PySimpleGUI window to update
# @param index ClassifImage index in images list
def loadImageAtIndex(window : sg.Window, index : int) -> None:
    image = Image.open(images[index].path)
    image.thumbnail((700, 700))
    bio = io.BytesIO()
    image.save(bio, format="PNG")
    window["currentImage"].update(data=bio.getvalue())
    window["imageName"].update(images[index].name)

## Performs whole operation of changing from one image to another in the visualizer
# @param window PysimpleGUI window to update
# @param indexToGo index from images list to load the image and relative information
def goToImage(window : sg.Window, indexToGo : int) -> None:
    global indexCurrentImage
    indexCurrentImage = indexToGo
    loadImageAtIndex(window, indexCurrentImage)
    
    aux = getLabelsNameList(images[indexCurrentImage].labels)
    window["labels"].set_value(aux)
    window["previous"].update(disabled=False)
    window["next"].update(disabled=False)

    if indexCurrentImage == 0:
        window["previous"].update(disabled=True)

    if indexCurrentImage == len(images) - 1:
        window["next"].update(disabled=True)

## Populates the images list, considering a folder with only images or
# a folder with the format of a classification folder
def populateImages() -> None:
    if os.path.exists(folderName + "/train") and os.path.exists(folderName + "/test"):
        
        names = list()
        for root, dirs, files in os.walk(folderName, topdown=True):
            
            for name in files:

                label = root.split("/")[-1]
                path = os.path.join(root, name)

                if name not in names:
                    names.append(name)
                    images[names.index(name)] = ClassifImage(path=path, name=name)

                images[names.index(name)].labels.append(label)

                if not label in labels:
                    labels.append(label)
    else:
        imagesPaths = (folderName + '/*.png', folderName + '/*.jpg') # the tuple of file types
        allImages = list()
        for image in imagesPaths:
            allImages.extend(glob(image))
        allImages = sorted(allImages)
        for index in range(len(allImages)):
            images[index] = ClassifImage(allImages[index], allImages[index].split("/")[-1])

## Auxiliary function to transform the event generated by the numpad to trigger the corresponding action
# @param event PySimpleGUI event generated from a sg.Window read()
def transformNumpad(event : str) -> str:

    if event is None:
        return event

    if "KP_End" in event:
        return "1"
    if "KP_Down" in event:
        return "2"
    if "KP_Next" in event:
        return "3"
    if "KP_Left" in event:
        return "4"
    if "KP_Begin" in event:
        return "5"
    if "KP_Right" in event:
        return "6"
    if "KP_Home" in event:
        return "7"
    if "KP_Up" in event:
        return "8"
    if "KP_Prior" in event:
        return "9"
    
    return event


def main():
    global images, labels
    global folderName
    global indexCurrentImage
    
    # arguments check
    if len(sys.argv) < 2:
        sg.popup_no_buttons("Please provide the correct arguments.")
        exit()

    folderName = sys.argv[1]

    # global lists and dicts initialization
    labels = list()
    images = dict()
    missingAnnotation = list()

    indexCurrentImage = 0

    # populate images list
    populateImages()

    if not images:
        sg.popup_no_buttons("Unfortunatly, the folder provided has no images", title=":(")
        os.system("python3 main.py")
        exit()

    # control variables
    proceed = False
    firstQuickAnnotation = True
    quickAnnotation = False
    defaultLabel = ""

    # main window creation and keyboard bindings
    window = sg.Window('Image Classification Annotation', gui.layout_classification, finalize=True, return_keyboard_events=True)
    window['labelToAdd'].bind("<Return>", "_enter")
    window["labelToAdd"].set_focus(True)
    window["numberImages"].update("Images loaded:" + str(len(images)))

    # load first image 
    goToImage(window, indexCurrentImage)
    window["labels"].update(getLabelsNameList(labels))
    aux = getLabelsNameList(images[indexCurrentImage].labels)
    window["labels"].set_value(aux)

    while True:

        event, values = window.read()
        # transform base numpad event 
        event = transformNumpad(event)

        if event in (sg.WIN_CLOSED, 'Exit'):
            break

        # add new label event
        if event == "addLabel" or event == "labelToAdd" + "_enter":
            labelToAdd = values["labelToAdd"]

            if not labelToAdd:
                continue

            if labelToAdd in labels:
                window['error'].update("Label already in \navailable classes!", text_color='maroon')
                continue

            labels.append(labelToAdd)

            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")
            
            aux = getLabelsNameList(images[indexCurrentImage].labels)
            window["labels"].set_value(aux)

            continue

        # remove label event
        if event == "removeLabel":
            labelToRemove = values["labelToAdd"]

            if not labelToRemove:
                continue

            if not labelToRemove in labels:
                window['error'].update("Label is non-existent!", text_color='maroon')
                continue

            for index in images:
                image = images[index]
                if labelToRemove in image.labels:
                    images[index].labels.remove(labelToRemove)
                    
            labels.remove(labelToRemove)

            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")

        # edit label event
        if event == "editLabel":
            labelToEdit = values["labelToAdd"]

            if not labelToEdit:
                continue

            if labelToEdit not in labels:
                window['error'].update("Label is non-existent!", text_color='maroon')
                continue

            replaceWith = labelToEdit


            replace_space = [[sg.Push(),sg.Text("Replace \"" + labelToEdit + "\" with:", font=gui.subtitleFont),sg.Push()],
                            [sg.Push(),sg.Input(replaceWith, key="replaceWith", font=gui.bodyFont),sg.Push()],
                            [sg.Push(),sg.Text(key="error-replace", font=gui.bodyFont),sg.Push()],
                            [sg.Push(),sg.Button("Save", key="save", font=gui.bodyFont),sg.Push()]]
            

            edit = sg.Window('Edit label', replace_space, keep_on_top=True, finalize=True, return_keyboard_events=True)

            edit['replaceWith'].bind("<Return>", "_enter")
            while (True):
                event, values = edit.read()

                if event in (sg.WIN_CLOSED, 'Exit'):
                    break

                if event == "save" or event == "replaceWith" + "_enter":

                    replaceWith = values["replaceWith"]
                    
                    if not replaceWith:
                        replaceWith = labelToEdit
                        continue

                    if replaceWith == labelToEdit:
                        break

                    if replaceWith in labels:
                        edit['error-replace'].update("Label already exists", text_color='maroon')
                        replaceWith = labelToEdit
                        continue

                    for index in images:
                        if labelToEdit in images.labels:
                            images[index].labels[labels.index(labelToEdit)] = replaceWith

                    labels[labels.index(labelToEdit)] = replaceWith
                    edit['error-replace'].update("")
                    break

            edit.close()
            
            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")

            aux = getLabelsNameList(images[indexCurrentImage].labels)
            window["labels"].set_value(aux)


        if event == "previous" or event == "Left:113":
            if indexCurrentImage - 1 < 0:
                continue
            
            goToImage(window, indexCurrentImage - 1)
            
            continue


        if event == "next" or event == "Right:114":
            if indexCurrentImage + 1 >= len(images):
                continue
            
            goToImage(window, indexCurrentImage + 1)
            
            continue


        if event == "labels":
            listNames = getLabelsNameList(labels)
            aux = list()
            for value in values["labels"]:
                index = listNames.index(value)
                aux.append(labels[index])

            images[indexCurrentImage].labels = aux

            continue


        if event == "continue":
            missingAnnotation = list()
            for index in images:
                image = images[index]
                if not image.labels:
                    # append index of image with missing annotation
                    missingAnnotation.append(index)

            defaultLabel = values["defaultLabel"] if values["defaultLabel"] else gui.defaultLabel

            ch = "No"
            if not missingAnnotation:
                ch = sg.popup_yes_no("  Once you continue and move on to the next phase, you won't be able to go back.\n" \
                                    "  Do you wish to proceed?",  title="Are you sure?")
            else:
                ch = sg.popup_yes_no("  Atention! You have " + str(len(missingAnnotation)) + " image(s) unlabeled!\n" \
                                    "  Go to 'All images' to check what you missed!\n\n" \
                                    "  Once you continue and move on to the next phase, you won't be able to go back.\n" \
                                    "  Do you wish to proceed?",  title="Are you sure?")

            if ch == "Yes":
                proceed = True
                break

            continue


        if event == "quickAnnotation":
            if firstQuickAnnotation:
                firstQuickAnnotation = False
                sg.Popup("  Quick annotation is a simple way to annotate your images " \
                        "using the first 9 classes you've possibly added.\n" \
                        "  All you have to do is type on your keyboard the number associated with the desired class. " \
                        "Moving between images with the arrow keys is always available. Try it! \n\n" \
                        "  P.S.: Adding new labels will be disabled while this functionality is on", title="Quick annotation")

            # disable input boxes
            quickAnnotation = not quickAnnotation
            window["labelToAdd"].update(disabled=quickAnnotation)
            window["defaultLabel"].update(disabled=quickAnnotation)
            window["addLabel"].update(disabled=quickAnnotation)
            window["removeLabel"].update(disabled=quickAnnotation)
            window["editLabel"].update(disabled=quickAnnotation)

            state = "ON" if quickAnnotation else "OFF"
            window["quickAnnotation"].update(state)

            continue


        if event == "allImages":
            justNames = list()

            for index in images:
                image = images[index]
                extra = ""
                if image.labels:
                    image.labels.sort()
                    extra = " (" + ", ".join(image.labels) + ")"
                justNames.append(image.name + extra)

            # creation of listbox layout
            layout_all_images = list()
            layout_all_images = [[sg.Push(),sg.Text("Images and their state (Labeled, Unlabeled)", font=gui.subtitleFont), sg.Push()],
                            [sg.Push(), sg.Listbox(values=justNames, size=(30, 30), enable_events=True,horizontal_scroll=True,
                                                font=gui.bodyFont,key="justNames", bind_return_key=True), sg.Push()],
                            [sg.Column([])],
                            [sg.Push(), sg.Button("Go to image", key="choose", font=gui.bodyFont), sg.Push()]]
            choose = sg.Window('Choose file', layout_all_images, keep_on_top=True, finalize=True)
        
            choose["justNames"].bind('<Double-Button-1>' , "_double")
            choose.write_event_value("start", None)
            while (True):
                event, values = choose.read()

                if event in (sg.WIN_CLOSED, 'Exit'):
                    break

                if event == "start":
                    for index in images:
                        image = images[index]
                        color_bg = "powder blue" if image.labels else "light coral"
                        color_fg = "white" if image.index == indexCurrentImage else "black"
                        choose['justNames'].Widget.itemconfig(image.index, bg=color_bg, fg=color_fg)

                if event == "choose" or event == "justNames" + "_double":
                    select = values["justNames"]
                    if not select:
                        break
                    
                    index = justNames.index(select[0])
                    goToImage(window, index)
                    break


            choose.close()
            
            continue


        if quickAnnotation:
            firstCharEvent = event.split(":", 1)[0]
            if firstCharEvent.isdigit() and int(firstCharEvent) <= len(labels):
                index = int(firstCharEvent) - 1
                # if already in list, remove
                if labels[index] in images[indexCurrentImage].labels:
                    images[indexCurrentImage].labels.remove(labels[index])
                else:
                    images[indexCurrentImage].labels.append(labels[index])
                aux = getLabelsNameList(images[indexCurrentImage].labels)
                window["labels"].set_value(aux)
                continue

        
    window.close()

    if not proceed:
        exit()

    if len(missingAnnotation) == len(images):
        sg.Popup("Since there are no labeled images, the program will close.", title=":(")
        exit()

    for missing in missingAnnotation:
        images[missing].labels.append(defaultLabel)
        if defaultLabel not in labels: 
            labels.append(defaultLabel)
                

    """ START OF DATABASE SAVE SCREN """

    window = sg.Window('Image Classification Annotation', gui.layout_save_dataset)
    pop = None
    maintainContent = False

    while True:

        event, values = window.read()

        if event in (sg.WIN_CLOSED, 'Exit'):
            break

        if event == "maintainContent":
            maintainContent = values["maintainContent"]

            if os.path.exists(values['folder']) and os.listdir(values['folder']) and maintainContent:
                window['error_folder'].update("Attention! Folder not empty. Will merge any existing content.", text_color='maroon')
                continue

            window['error_folder'].update("")    

        if event == "folder" and values['folder']:
            if os.path.exists(values['folder']) and os.listdir(values['folder']) and maintainContent:
                window['error_folder'].update("Attention! Folder not empty. Will merge any existing content.", text_color='maroon')
                continue

            window['error_folder'].update("")

        if event == "go":
            destinationFolder = values["folder"]
            if not destinationFolder:
                continue

            train = int(values["train"])/100
            test = int(values["test"])/100
            val = int(values["val"])/100

            if train + test + val != 1:
                window['error_split'].update("Split ratio needs to total 100%!", text_color='maroon')
                continue

            window['error_split'].update("")
            window['error_folder'].update("")

            window.Hide()
            pop = gui.popup("Processing...")

            
            if not os.path.exists(destinationFolder):
                os.mkdir(destinationFolder)

            # create temporary folder with classes and their corresponding images
            for index in images:
                imageLabels = images[index].labels
                imageAddress = images[index].path

                for label in imageLabels:
                    destinationPath = destinationFolder + "/labels/" + label
                    
                    if not os.path.exists(destinationPath):  
                        os.makedirs(destinationPath)

                    shutil.copy(imageAddress, destinationPath)

            done = False
            error = ""
            try:
                
                # split folders in trian test and validation
                splitfolders.ratio(destinationFolder + "/labels", seed=1337, output=destinationFolder + "/temp", ratio=(train, test, val))
                
                if not maintainContent:
                    for clean_up in glob(destinationFolder + "/*"):
                        if not clean_up.endswith('/temp'):    
                            shutil.rmtree(clean_up, ignore_errors=True)
                
                shutil.copytree(destinationFolder + "/temp", destinationFolder, dirs_exist_ok=True)
                shutil.rmtree(destinationFolder + "/labels", ignore_errors=True)
                shutil.rmtree(destinationFolder + "/temp", ignore_errors=True)
                
                done = True
            except Exception as e:
                error = e
                

            pop.close()
            window.UnHide()
            if done:
                sg.Popup("Done!", title=":)")
            else:
                sg.Popup(error, title="An error occured")

            shutil.rmtree(destinationFolder + "/dataset", ignore_errors=True)
            shutil.rmtree(destinationFolder + "/temp", ignore_errors=True)
                
            continue

if __name__ == "__main__":
    main()