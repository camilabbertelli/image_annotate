## @package camicasa
# package for all functions, methods and classes create by Camila Bertelli

import os
import io
import sys
import gui
import shutil
import splitfolders
from glob import glob
from PIL import Image
from gui import sg

## Class destinated to store information about an image in the classification context
class ClassifImage:
    globalIndex = 0

    ## The constructor
    # @param self The object pointer
    # @param path The complete image path
    # @param name The image the image will go by, containing the extension, i.e. image.jpg, 001.png
    def __init__(self, path : str, name: str) -> 'ClassifImage':
        self.index = ClassifImage.globalIndex
        ClassifImage.globalIndex += 1
        self.path = path
        self.name = name
        # list of Label
        self.labels = list()

## Returns list of strings to be presented in the labels listbox,
# considering number on the left
# @param vectorLabels vector of labels to add indexes on the left
def getLabelsNameList(vectorLabels : list) -> list:
    aux = list()
    for label in vectorLabels:
        index = labels.index(label)
        aux.append(str(index + 1) + ": " + label)
    return aux

## Loads image on image container(sg.Image) and updates related information 
# @param window PySimpleGUI window to update
# @param index ClassifImage index in images list
def loadImageAtIndex(window : sg.Window, index : int) -> None:
    image = Image.open(images[index].path)
    image.thumbnail((700, 700))
    bio = io.BytesIO()
    image.save(bio, format="PNG")
    window["currentImage"].update(data=bio.getvalue())
    window["imageName"].update(images[index].name)

## Performs whole operation of changing from one image to another in the visualizer
# @param window PysimpleGUI window to update
# @param indexToGo index from images list to load the image and relative information
def goToImage(window : sg.Window, indexToGo : int) -> None:
    global indexCurrentImage
    indexCurrentImage = indexToGo
    loadImageAtIndex(window, indexCurrentImage)
    
    aux = getLabelsNameList(images[indexCurrentImage].labels)
    window["labels"].set_value(aux)
    window["previous"].update(disabled=False)
    window["next"].update(disabled=False)

    if indexCurrentImage == 0:
        window["previous"].update(disabled=True)

    if indexCurrentImage == len(images) - 1:
        window["next"].update(disabled=True)

## Populates the images list, considering a folder with only images or
# a folder with the format of a classification folder
def populateImages() -> None:
    if os.path.exists(folderName + "/train") and os.path.exists(folderName + "/test"):
        
        names = list()
        for root, dirs, files in os.walk(folderName, topdown=True):
            
            for name in files:

                label = root.split("/")[-1]
                path = os.path.join(root, name)

                if name not in names:
                    names.append(name)
                    images[names.index(name)] = ClassifImage(path=path, name=name)

                images[names.index(name)].labels.append(label)

                if not label in labels:
                    labels.append(label)
    else:
        imagesPaths = (folderName + '/*.png', folderName + '/*.jpg') # the tuple of file types
        allImages = list()
        for image in imagesPaths:
            allImages.extend(glob(image))
        allImages = sorted(allImages)
        for index in range(len(allImages)):
            images[index] = ClassifImage(allImages[index], allImages[index].split("/")[-1])

## Auxiliary function to transform the event generated by the numpad to trigger the corresponding action
# @param event PySimpleGUI event generated from a sg.Window read()
def transformNumpad(event : str) -> str:

    if event is None:
        return event

    if "KP_End" in event:
        return "1"
    if "KP_Down" in event:
        return "2"
    if "KP_Next" in event:
        return "3"
    if "KP_Left" in event:
        return "4"
    if "KP_Begin" in event:
        return "5"
    if "KP_Right" in event:
        return "6"
    if "KP_Home" in event:
        return "7"
    if "KP_Up" in event:
        return "8"
    if "KP_Prior" in event:
        return "9"
    
    return event


def main():
    global images, labels
    global folderName
    global indexCurrentImage
    
    # arguments check
    if len(sys.argv) < 2:
        sg.popup_no_buttons("Please provide the correct arguments.")
        exit()

    folderName = sys.argv[1]

    # global lists and dicts initialization
    labels = list()
    images = dict()
    missingAnnotation = list()

    indexCurrentImage = 0

    # populate images list
    populateImages()

    if not images:
        sg.popup_no_buttons("Unfortunatly, the folder provided has no images", title=":(")
        os.system("python3 main.py")
        exit()

    # control variables
    proceed = False
    firstQuickAnnotation = True
    quickAnnotation = False
    defaultLabel = ""

    # main window creation and keyboard bindings
    window = sg.Window('Image Classification Annotation', gui.layout_classification, finalize=True, return_keyboard_events=True)
    window['labelToAdd'].bind("<Return>", "_enter")
    window["labelToAdd"].set_focus(True)
    window["numberImages"].update("Images loaded:" + str(len(images)))

    # load first image 
    goToImage(window, indexCurrentImage)
    window["labels"].update(getLabelsNameList(labels))
    aux = getLabelsNameList(images[indexCurrentImage].labels)
    window["labels"].set_value(aux)

    while True:

        event, values = window.read()
        # transform base numpad event 
        event = transformNumpad(event)

        if event in (sg.WIN_CLOSED, 'Exit'):
            break

        # add new label event
        if event == "addLabel" or event == "labelToAdd" + "_enter":
            labelToAdd = values["labelToAdd"]

            if not labelToAdd:
                continue

            if labelToAdd in labels:
                window['error'].update("Label already in \navailable classes!", text_color='maroon')
                continue

            labels.append(labelToAdd)

            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")
            
            aux = getLabelsNameList(images[indexCurrentImage].labels)
            window["labels"].set_value(aux)

            continue

        # remove label event
        if event == "removeLabel":
            labelToRemove = values["labelToAdd"]
            yes = False

            if not labelToRemove:
                continue

            if not labelToRemove in labels:
                window['error'].update("Label is non-existent!", text_color='maroon')
                continue

            # confirmation of removal window
            remove_space = [[sg.Push(),sg.Text("Remove \"" + labelToRemove + "\" selection from all images?", font=gui.subtitleFont), sg.Push()],
                            [sg.Push(),sg.Button("Yes", key="yes", font=gui.bodyFont), sg.Push(), sg.Button("No", key="no", font=gui.bodyFont),sg.Push()]]
            
            remove = sg.Window('Are you sure?', remove_space, keep_on_top=True, finalize=True)
            while (True):
                event, values = remove.read()

                if event in (sg.WIN_CLOSED, 'Exit'):
                    break

                if event == "yes":
                    yes = True
                    break

                if event == "no":
                    break
            
            remove.close()
            
            if not yes:
                continue

            for index in images:
                image = images[index]
                if labelToRemove in image.labels:
                    images[index].labels.remove(labelToRemove)
                    
            labels.remove(labelToRemove)

            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")

            continue

        # edit label event
        if event == "editLabel":
            labelToEdit = values["labelToAdd"]

            if not labelToEdit:
                continue

            if labelToEdit not in labels:
                window['error'].update("Label is non-existent!", text_color='maroon')
                continue

            replaceWith = labelToEdit

            # creation of new window 
            replace_space = [[sg.Push(),sg.Text("Replace \"" + labelToEdit + "\" with:", font=gui.subtitleFont),sg.Push()],
                            [sg.Push(),sg.Input(replaceWith, key="replaceWith", font=gui.bodyFont),sg.Push()],
                            [sg.Push(),sg.Text(key="error-replace", font=gui.bodyFont),sg.Push()],
                            [sg.Push(),sg.Button("Save", key="save", font=gui.bodyFont),sg.Push()]]
            

            edit = sg.Window('Edit label', replace_space, keep_on_top=True, finalize=True, return_keyboard_events=True)

            edit['replaceWith'].bind("<Return>", "_enter")
            while (True):
                event, values = edit.read()

                if event in (sg.WIN_CLOSED, 'Exit'):
                    break

                if event == "save" or event == "replaceWith" + "_enter":

                    replaceWith = values["replaceWith"]
                    
                    if not replaceWith:
                        replaceWith = labelToEdit
                        continue

                    if replaceWith == labelToEdit:
                        break

                    if replaceWith in labels:
                        edit['error-replace'].update("Label already exists", text_color='maroon')
                        replaceWith = labelToEdit
                        continue

                    for index in images:
                        if labelToEdit in images.labels:
                            images[index].labels[labels.index(labelToEdit)] = replaceWith

                    labels[labels.index(labelToEdit)] = replaceWith
                    edit['error-replace'].update("")
                    break

            edit.close()
            
            window["labels"].update(getLabelsNameList(labels))
            window["labelToAdd"].update("")
            window['error'].update("")

            aux = getLabelsNameList(images[indexCurrentImage].labels)
            window["labels"].set_value(aux)
            continue

        # previous button event
        if event == "previous" or event == "Left:113":
            if indexCurrentImage - 1 < 0:
                continue
            
            goToImage(window, indexCurrentImage - 1)
            
            continue

        # next button event
        if event == "next" or event == "Right:114":
            if indexCurrentImage + 1 >= len(images):
                continue
            
            goToImage(window, indexCurrentImage + 1)
            
            continue

        # click on labels listbox event 
        if event == "labels":
            listNames = getLabelsNameList(labels)
            aux = list()
            for value in values["labels"]:
                index = listNames.index(value)
                aux.append(labels[index])

            images[indexCurrentImage].labels = aux

            continue

        # proceed to the next phase event
        if event == "continue":
            missingAnnotation = list()
            for index in images:
                image = images[index]
                if not image.labels:
                    # append index of image with missing annotation
                    missingAnnotation.append(index)

            defaultLabel = values["defaultLabel"] if values["defaultLabel"] else gui.defaultLabel

            ch = "No"
            if not missingAnnotation:
                ch = sg.popup_yes_no("  Once you continue and move on to the next phase, you won't be able to go back.\n" \
                                    "  Do you wish to proceed?",  title="Are you sure?")
            else:
                ch = sg.popup_yes_no("  Atention! You have " + str(len(missingAnnotation)) + " image(s) unlabeled!\n" \
                                    "  Go to 'All images' to check what you missed!\n\n" \
                                    "  Once you continue and move on to the next phase, you won't be able to go back.\n" \
                                    "  Do you wish to proceed?",  title="Are you sure?")

            if ch == "Yes":
                proceed = True
                break

            continue

        # show relation of all images event
        if event == "allImages":
            justNames = list()

            # gather all labels associated with an especific image
            for index in images:
                image = images[index]
                extra = ""
                if image.labels:
                    image.labels.sort()
                    extra = " (" + ", ".join(image.labels) + ")"
                justNames.append(image.name + extra)

            # creation of listbox layout
            layout_all_images = list()
            layout_all_images = [[sg.Push(),sg.Text("Images and their state (Labeled, Unlabeled)", font=gui.subtitleFont), sg.Push()],
                            [sg.Push(), sg.Listbox(values=justNames, size=(30, 30), enable_events=True,horizontal_scroll=True,
                                                font=gui.bodyFont,key="justNames", bind_return_key=True), sg.Push()],
                            [sg.Column([])],
                            [sg.Push(), sg.Button("Go to image", key="choose", font=gui.bodyFont), sg.Push()]]
            
            choose = sg.Window('Choose file', layout_all_images, keep_on_top=True, finalize=True)
            choose["justNames"].bind('<Double-Button-1>' , "_double")

            # color code elements
            for index in images:
                image = images[index]
                color_bg = "powder blue" if image.labels else "light coral"
                color_fg = "white" if image.index == indexCurrentImage else "black"
                choose['justNames'].Widget.itemconfig(image.index, bg=color_bg, fg=color_fg)

            while (True):
                event, values = choose.read()

                if event in (sg.WIN_CLOSED, 'Exit'):
                    break
                    
                if event == "choose" or event == "justNames" + "_double":
                    select = values["justNames"]
                    if not select:
                        break
                    
                    index = justNames.index(select[0])
                    goToImage(window, index)
                    break


            choose.close()
            
            continue

        # enable/disable "quickAnnotation" feature event 
        if event == "quickAnnotation":
            if firstQuickAnnotation:
                firstQuickAnnotation = False
                sg.Popup("  Quick annotation is a simple way to annotate your images " \
                        "using the first 9 classes you've possibly added.\n" \
                        "  All you have to do is type on your keyboard the number associated with the desired class. " \
                        "Moving between images with the arrow keys is always available. Try it! \n\n" \
                        "  P.S.: Adding new labels will be disabled while this functionality is on", title="Quick annotation")

            # disable input boxes
            quickAnnotation = not quickAnnotation
            window["labelToAdd"].update(disabled=quickAnnotation)
            window["defaultLabel"].update(disabled=quickAnnotation)
            window["addLabel"].update(disabled=quickAnnotation)
            window["removeLabel"].update(disabled=quickAnnotation)
            window["editLabel"].update(disabled=quickAnnotation)

            state = "ON" if quickAnnotation else "OFF"
            window["quickAnnotation"].update(state)

            continue

        # handle numpad and number keyboard keys when quickAnnotation is active
        if quickAnnotation:
            firstCharEvent = event.split(":", 1)[0]
            if firstCharEvent.isdigit() and int(firstCharEvent) <= len(labels):
                index = int(firstCharEvent) - 1
                # if already in list, remove
                if labels[index] in images[indexCurrentImage].labels:
                    images[indexCurrentImage].labels.remove(labels[index])
                else:
                    images[indexCurrentImage].labels.append(labels[index])
                aux = getLabelsNameList(images[indexCurrentImage].labels)
                window["labels"].set_value(aux)
                continue

        
    window.close()

    if not proceed:
        exit()

    if len(missingAnnotation) == len(images):
        sg.Popup("Since there are no labeled images, the program will close.", title=":(")
        exit()

    # add default label to images with no classification
    for missing in missingAnnotation:
        images[missing].labels.append(defaultLabel)
        if defaultLabel not in labels: 
            labels.append(defaultLabel)
                

    """ START OF DATABASE SAVE SCREN """

    window = sg.Window('Image Classification Annotation', gui.layout_save_dataset)
    pop = None
    maintainContent = False

    while True:

        event, values = window.read()

        if event in (sg.WIN_CLOSED, 'Exit'):
            break

        # maintain content event
        # if checked, doesn't wipe out content on the selected destination folder
        if event == "maintainContent":
            maintainContent = values["maintainContent"]

            if os.path.exists(values['folder']) and os.listdir(values['folder']) and maintainContent:
                window['error_folder'].update("Attention! Folder not empty. Will merge any existing content.", text_color='maroon')
                continue

            window['error_folder'].update("")    

        # select destination folder event
        if event == "folder" and values['folder']:
            if os.path.exists(values['folder']) and os.listdir(values['folder']) and maintainContent:
                window['error_folder'].update("Attention! Folder not empty. Will merge any existing content.", text_color='maroon')
                continue

            window['error_folder'].update("")

        # saves dataset
        if event == "go":
            destinationFolder = values["folder"]
            if not destinationFolder:
                continue

            train = int(values["train"])/100
            test = int(values["test"])/100
            val = int(values["val"])/100

            if train + test + val != 1:
                window['error_split'].update("Split ratio needs to total 100%!", text_color='maroon')
                continue

            window['error_split'].update("")
            window['error_folder'].update("")

            window.Hide()
            pop = gui.popup("Processing...")

            if not os.path.exists(destinationFolder):
                os.mkdir(destinationFolder)

            # 
            # the following steps occur in this stage:
            # 1. creation of a temporary folder /temp-aux with subfolders corresponding to classes and their classified images
            # 2. the splitfolders module then takes these subfolders and splits them in train, test and validation sets
            #
            # Check https://pypi.org/project/split-folders/ for more information
            #
            #     
            #                             train/
            #                                 class1/
            #                                     img1.jpg
            #                                     ...
            #  class1/                        class2/
            #      img1.jpg                       imgA.jpg
            #      img2.jpg                       ...
            #      img3.jpg               val/
            #      ...            -->         class1/
            #  class2/                            img2.jpg
            #      imgA.jpg                       ...
            #      imgB.jpg                   class2/
            #      imgC.jpg                       imgB.jpg
            #      ...                            ...
            #  ...                        test
            #                                 class1/
            #                                     img3.jpg
            #                                     ...
            #                                 class2/
            #                                     imgC.jpg
            #                                     ...
            #
            #
            # 3. move everything done to the final destination folder


            for index in images:
                imageLabels = images[index].labels
                imageAddress = images[index].path

                for label in imageLabels:
                    destinationPath = destinationFolder + "/temp-aux/" + label
                    
                    if not os.path.exists(destinationPath):  
                        os.makedirs(destinationPath)

                    shutil.copy(imageAddress, destinationPath)

            done = False
            error = ""
            try:
                
                # split folders in trian test and validation
                splitfolders.ratio(destinationFolder + "/temp-aux", seed=1337, output=destinationFolder + "/temp", ratio=(train, test, val), move=True)
                
                # clear unwanted content from destinationFolder 
                if not maintainContent:
                    for clean_up in glob(destinationFolder + "/*"):
                        if not clean_up.endswith('/temp'):    
                            shutil.rmtree(clean_up, ignore_errors=True)
                
                shutil.copytree(destinationFolder + "/temp", destinationFolder, dirs_exist_ok=True)
                shutil.rmtree(destinationFolder + "/temp-aux", ignore_errors=True)
                shutil.rmtree(destinationFolder + "/temp", ignore_errors=True)
                
                done = True
            except Exception as e:
                error = e
                

            pop.close()
            window.UnHide()
            if done:
                sg.Popup("Done!", title=":)")
            else:
                sg.Popup(error, title="An error occured")

            shutil.rmtree(destinationFolder + "/dataset", ignore_errors=True)
            shutil.rmtree(destinationFolder + "/temp", ignore_errors=True)
                
            continue

if __name__ == "__main__":
    main()